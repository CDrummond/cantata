#!/usr/bin/env perl

#  Cantata-Dynamic
#
#  Copyright (c) 2011-2012 Craig Drummond <craig.p.drummond@gmail.com>
#
#  ----
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; see the file COPYING.  If not, write to
#  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
#  Boston, MA 02110-1301, USA.

use IO::Socket::INET;
use POSIX;

$PLAY_QUEUE_DESIRED_LENGTH=10;
$PLAY_QUEUE_CURRENT_POS=5;

$host="localhost";
$port="6600";
$passwd="";

# Read MPDs host, port, and password details from env - if set
sub readConnectionDetails() {
    my $hostEnv=$ENV{'MPD_HOST'};
    my $portEnv=$ENV{'MPD_PORT'};
    if (length($portEnv)>2) {
        $port=$portEnv;
    }

    if (length($hostEnv)>2) {
        my $sep = index($hostEnv, '@');

        if ($sep>0) {
            $passwd=substr($hostEnv, 0, $sep);
            $host=substr($hostEnv, $sep+1, length($hostEnv)-$sep);
        } else {
            $host=$hostEnv;
        }
    }
}

$socketData="";
sub readReply() {
    local $data;
    $socketData="";
    while (1) {
        $sock->recv($data, 1024);
        if (! $data) {
            return 0;
        }
        $socketData="${socketData}${data}";
        $data="";

        if (($socketData=~ m/(OK)$/) || ($socketData=~ m/^(OK)/) || ($socketData=~ m/^(ACK)/)) {
            $ok=1;
            return 1;
        }
    }
}

# Connect to MPD
sub connectToMpd() {
    if ($host=~ m/^(\/)/) {
        $sock = new IO::Socket::UNIX(PeerAddr => $host, Type => SOCK_DGRAM);
    } else {
        $sock = new IO::Socket::INET(PeerAddr => $host, PeerPort => $port, Proto => 'tcp');
    }
    if ($sock->connected()) {
        if (&readReply()) {
            if ($passwd) {
                $sock->send("password ${passwd} \n");
                if (! &readReply()) {
                    print "ERROR: Invalid password\n";
                    close($sock);
                    return 0;
                }
            }
        } else {
            close($sock);
            return 0;
        }
        return 1;
    }
    return 0;
}

# Disconnect from MPD
sub disconnectFromMpd() {
    if ($sock->connected()) {
        close($sock);
    }
}

sub sendCommand() {
    my $cmd = shift;
    my $status = 0;
    if (&connectToMpd()) {
        $sock->send("${cmd}\n");
        if (&readReply()) {
            $status=1;
        }
        &disconnectFromMpd();
    }

    return $status;
}

sub waitForEvent() {
    if (&connectToMpd()) {
        $sock->send("idle playlist\n");
        readReply();
    }
}

# Check if MPD is running
sub mpdIsRunning() {
    if (&connectToMpd()) {
        &disconnectFromMpd();
        return 1;
    }

    return 0;
}

sub baseDir() {
    my $cacheDir=$ENV{'XDG_CACHE_HOME'};
    if (!$cacheDir) {
        $cacheDir="$ENV{'HOME'}/.cache";
    }
    $cacheDir="${cacheDir}/cantata/dynamic";
    return $cacheDir
}

sub lockFile() {
    my $fileName=&baseDir();
    $fileName="${fileName}/lock";
    return $fileName;
}

$rulesChanged=1;
$rules;
$lastRules;
$initialRead=1;
sub checkRulesChanged() {
    if ($initialRead==1) { # Always changed on first run...
        $rulesChanged=1;
        $initialRead=0;
    } elsif (scalar(@lastRules)!=scalar(@rules)) {
        $rulesChanged=1;
    } else {
        $rulesChanged=0;
        for (my $i=0; $i<scalar(@rules) && $rulesChanged==0; $i++) {
            if ($rules[$i] ne $lastRules[$i]) {
                $rulesChanged=1;
            }
        }
    }
    @lastRules=@rules;
}

# Read rules from ~/.cache/cantata/dynamic/rules
sub readRules() {
    ## TODO: Compare timestamp of rules file (where it links to) to check for changes...
    my $fileName=&baseDir();
    $fileName="${fileName}/rules";

    for(my $i=0; $i<10; $i++) {
        open(HANDLE, $fileName);
        if (tell(HANDLE) != -1) {
            my @lines = <HANDLE>; # Read into an array...
            my $ruleNum=-1;
            my $ruleMatch="find";
            my $dates="";
            foreach my $line (@lines) {
                if (! ($line=~ m/^(#)/)) {
                    $line =~ s/\n//g;
                    my $sep = index($line, ':');

                    if ($sep>0) {
                        $key=substr($line, 0, $sep);
                        $val=substr($line, $sep+1, length($line)-$sep);
                    } else {
                        $key=$line;
                        $val="";
                    }
                    if ($key=~ m/^(Rule)/) { # New rule...
                        if ($ruleNum>=0 && scalar(@dates)>0) { # Create rule for each date (as MPDs search does not take ranges)
                            my $baseRule=${rules[${ruleNum}]};
                            foreach my $date (@dates) {
                                $rules[$ruleNum]="${ruleMatch} ${baseRule} Date \"${date}\"";
                                $ruleNum++;
                            }
                            $dates="";
                        } else {
                            if ($ruleNum>=0) {
                                $rules[$ruleNum]="${ruleMatch} ${rules[$ruleNum]}";
                            }
                            $ruleNum++;
                        }
                    } elsif ($ruleNum >= 0) {
                        if ($key eq "Date") {
                            my @dateVals = split("-", $val);
                            if (scalar(@dateVals)==2) {
                                my $fromDate=scalar($dateVals[0]);
                                my $toDate=scalar($dateVals[1]);
                                if ($fromDate > $toDate) { # Fix dates if from>to!!!
                                    my $tmp=$fromDate;
                                    $fromDate=$toDate;
                                    $toDate=$tmp;
                                }
                                my $pos=0;
                                for(my $d=$fromDate; $d<=$toDate; $d++) {
                                    $dates[$pos]=$d;
                                    $pos++;
                                }
                            } else {
                                @dates=($val)
                            }
                        } elsif ($key eq "Artist" || $key eq "Album" || $key eq "AlbumArtist" || $key eq "Title" || $key eq "Genre") {
                            $rules[$ruleNum]="${rules[$ruleNum]} ${key} \"${val}\"";
                        } elsif ($key eq "Exact" && $val eq "false") {
                            $ruleMatch="search"
                        }
                    }
                }
            }

            if ($ruleNum>=0) {
                if (scalar(@dates)>0) { # Create rule for each date (as MPDs search does not take ranges)
                    my $baseRule=${rules[${ruleNum}]};
                    foreach my $date (@dates) {
                        $rules[$ruleNum]="${ruleMatch} ${baseRule} Date \"${date}\"";
                        $ruleNum++;
                    }
                } else {
                    $rules[$ruleNum]="${ruleMatch} ${rules[$ruleNum]}";
                }
            }

            &checkRulesChanged();
            return 1;
        }
        sleep 1
    }
    &checkRulesChanged();
    return 0;
}

sub uniq {
    my %seen = ();
    my @r = ();
    foreach my $a (@_) {
        unless ($seen{$a}) {
            push @r, $a;
            $seen{$a} = 1;
        }
    }
    return @r;
}

# Use rules to obtain a list of songs from MPD...
sub getSongs() {
    # If we have no current songs, or rules have changed, or MPD has been updated - then we need to run the rules against MPD to get song list...
    if (scalar(@mpdSongs)<1 || $rulesChanged==1 || $mpdDbUpdate!=$lastMpdDbUpdate) {
        if (scalar(@rules)>0) {
            $mpdSongs="";
            my $mpdSong=0;
            foreach my $rule (@rules) {
                &sendCommand($rule);
                my @lines = split('\n', $socketData);
                foreach my $line (@lines) {
                    if ($line=~ m/^(file\:)/) {
                        my $sep = index($line, ':');
                        if ($sep>0) {
                            $mpdSongs[$mpdSong]=substr($line, $sep+2, length($line)-($sep+1));
                            $mpdSong++;
                        }
                    }
                }
            }
            @mpdSongs=uniq(@mpdSongs);
        } else {
            # No rules, random *all* songs...
            &sendCommand("listall");
            my @lines = split('\n', $socketData);
            foreach my $line (@lines) {
                if ($line=~ m/^(file\:)/) {
                    my $sep = index($line, ':');
                    if ($sep>0) {
                        $mpdSongs[$mpdSong]=substr($line, $sep+2, length($line)-($sep+1));
                        $mpdSong++;
                    }
                }
            }
        }
    }
}

@playQueueHistory=();
$playQueueHistoryLimit=0;
$playQueueHistoryPos=0;
sub canAdd() {
    my $file=shift;
    my $numSongs=shift;
    my $pqLimit=0;

    if ($numSongs>50) {
        $pqLimit=50;
    } elsif ($numSongs>25) {
        $pqLimit=25;
    } elsif ($numSongs>10) {
        $pqLimit=10;
    } elsif ($numSongs>5) {
        $pqLimit=5;
    } else {
        $pqLimit=2;
    }

    if ($pqLimit != $playQueueHistoryLimit) {
        $playQueueHistoryLimit=$pqLimit;
        @playQueueHistory=();
        return 1;
    }

    my $size=scalar(@playQueueHistory);
    if ($size>$playQueueHistoryLimit) {
        $size=$playQueueHistoryLimit;
    }

    for (my $i=0; $i<$size; ++$i) {
        if ($playQueueHistory[$i] eq $file) {
            return 0;
        }
    }
    return 1;
}

sub storeSong() {
    my $file=shift;
    if ($playQueueHistoryLimit<=0) {
        $playQueueHistoryLimit=5;
    }

    if ($playQueueHistoryPos>=$playQueueHistoryLimit) {
        $playQueueHistoryPos=0;
    }
    $playQueueHistory[$playQueueHistoryPos]=$file;
    $playQueueHistoryPos++;
}

sub populatePlayQueue() {
    &readConnectionDetails();
    my $mpdDbUpdate=0;
    my $lastMpdDbUpdate=-1;
    while (1) {
        if (&sendCommand("status")) {
            my @lines = split('\n', $socketData);
            my $playQueueLength=0;
            my $playQueueCurrentTrackPos=0;
            foreach my $val (@lines) {
                if ($val=~ m/^(song\:)/) {
                    my @vals = split(": ", $val);
                    if (scalar(@vals)==2) {
                        $playQueueCurrentTrackPos=scalar($vals[1]);
                    }
                    break;
                }
            }

            if (&sendCommand("stats")) {
                my @lines = split('\n', $socketData);
                foreach my $val (@lines) {
                    if ($val=~ m/^(db_update\:)/) {
                        my @vals = split(": ", $val);
                        if (scalar(@vals)==2) {
                            $mpdDbUpdate=scalar($vals[1]);
                        }
                        break;
                    }
                }
            }

            if (&sendCommand("playlist")) {
                my @lines = split('\n', $socketData);
                my $playQueueLength=scalar(@lines);
                if ($playQueueLength>0 && $lines[$playQueueLength-1]=~ m/^(OK)/) {
                    $playQueueLength--;
                }

                # trim playlist start so that current becomes <=$PLAY_QUEUE_CURRENT_POS
                for (my $i=0; $i < $playQueueCurrentTrackPos - ($PLAY_QUEUE_CURRENT_POS-1); $i++) {
                    &sendCommand("delete 0");
                    $playQueueLength--;
                }
                if ($playQueueLength<0) {
                    $playQueueLength=0;
                }

                &readRules();
                &getSongs();
                my $numMpdSongs=scalar(@mpdSongs);
                if ($numMpdSongs>0) {
                    # fill up playlist to 10 random tunes
                    my $failues=0;
                    while ($playQueueLength < $PLAY_QUEUE_DESIRED_LENGTH) {
                        my $pos=int(rand($numMpdSongs));
                        if ($failues > 100 || &canAdd(${mpdSongs[$pos]}, $numMpdSongs)) {
                            if (&sendCommand("add \"${mpdSongs[$pos]}\"")) {
                                &storeSong(${mpdSongs[$pos]});
                                $playQueueLength++;
                                $failues=0;
                            }
                        } else { # Song is already in playqueue history...
                            $failues++;
                        }
                    }
                }

               &waitForEvent();
            } else {
                sleep 5;
            }
        } else {
            sleep 5;
        }
    }
}

sub readPid() {
    my $fileName=&lockFile();

    if (-e $fileName) {
        open(HANDLE, $fileName);
        my @lines = <HANDLE>;
        if (scalar(@lines)>0) {
            my $pid=$lines[0];
            return scalar($pid);
        }
    }
    return 0;
}

sub start() {
    my $fileName=&lockFile();

    if (-e $fileName) {
        my $pid=&readPid();
        if ($pid>0) {
            $exists = kill 0, $pid;
            if ($exists) {
                print "PROCESS $pid is running!\n";
                return;
            }
        }
    }

    chdir '/';
    umask 0;
    open STDIN,  '/dev/null'   or die "Can't read /dev/null: $!";
    open STDOUT, '>>/dev/null' or die "Can't write to /dev/null: $!";
    open STDERR, '>>/dev/null' or die "Can't write to /dev/null: $!";
    defined( my $pid = fork ) or die "Can't fork: $!";
    exit if $pid;

    # dissociate this process from the controlling terminal that started it and stop being part
    # of whatever process group this process was a part of.
    POSIX::setsid() or die "Can't start a new session.";

    # callback signal handler for signals.
    $SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signalHandler;
    $SIG{PIPE} = 'ignore';

    open(HANDLE, ">${fileName}");
    print HANDLE $$;
    close HANDLE;
    &populatePlayQueue();
}

sub signalHandler {
    unlink(&lockFile());
    exit(0);
}

sub stop() {
    my $pid=&readPid();
    if ($pid>0) {
        system("kill", $pid);
        system("pkill", "-P", $pid);
    }
}

if ($ARGV[0] eq "start") {
    &start();
} elsif ($ARGV[0] eq "stop") {
    &stop();
} elsif ($ARGV[0] eq "test") {
    &populatePlayQueue();
} else {
    print "Usage: $0 start|stop\n";
}
